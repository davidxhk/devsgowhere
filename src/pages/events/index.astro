---
import BaseHead from "../../components/BaseHead.astro";
import Header from "../../components/Header.astro";
import Theme from "../../layouts/Theme.astro";
import Footer from "../../components/Footer.astro";

import { SITE_TITLE, SITE_DESCRIPTION } from "../../consts";
import { getCollection } from "astro:content";
import EventCard from "../../components/EventCard.astro";

const now = new Date();
const events = (await getCollection("events"))
  .filter((event) => {
    const startDate = new Date(event.data.startDate);
    startDate.setDate(startDate.getDate() + 1) // Add 1 day
    return startDate >= now;
  })
  .sort(
    (a, b) =>
      new Date(a.data.startDate).valueOf() -
      new Date(b.data.startDate).valueOf(),
  );  

// Group events by date
const groupedEvents = events.reduce((acc, event) => {
  const date = new Date(event.data.startDate).toLocaleDateString('en-US', { weekday: 'short', month: 'long', day: 'numeric', year: 'numeric' });
  console.log("Event Date:", date, "Event ID:", event.id);
  if (!acc[date]) {
    acc[date] = [];
  }
  acc[date].push(event);
  return acc;
}, {});

//Get ALL events (past and future)
const eventsAll = (await getCollection("events"))
//Extract all unique tags from ALL events
// Get all tags with their counts, filter out tags with count < 5, and sort alphabetically
const allTags = eventsAll.flatMap(event => (event.data.tags ?? []));  
console.log("All Tags: ", allTags);
const normalisedTags = allTags.map(tag => tag.toLowerCase());
console.log("Normalised Tags: ", normalisedTags);
const tagCounts = normalisedTags.reduce((output: Record<string, number>, tag) => {
  if(!output[tag]){
    output[tag] = 0;
  }
  output[tag] += 1;
  return output;
}, {});
console.log("Tag count: ", tagCounts);

const uniqueTags = Object.keys(tagCounts);
console.log("Unique Tags: ", uniqueTags);

const filteredTags = uniqueTags
  .filter(tag => tag.length <= 20)
  //.filter(tag => tagCounts[tag] >= 2)
  .sort((a, b) => tagCounts[b] - tagCounts[a]);
  console.log("Tag filtered: ", filteredTags);

  const top20Tags = filteredTags.slice(0, 20).sort();
  console.log("Top 20 Tags: ", top20Tags);

  const currentEventTags = events.flatMap(event => (event.data.tags ?? []));
  console.log("Current event tags: ", currentEventTags);
  const normalisedCurrentEventTags = currentEventTags.map(tag => tag.toLowerCase());
  console.log("Curr Event Normalised Tags: ", normalisedCurrentEventTags);
  const mergedTags = Array.from(new Set([...top20Tags, ...normalisedCurrentEventTags])).sort();
  console.log("Final tags: ", mergedTags);

---

<!doctype html>
<html lang="en">
  <head>
    <BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
    <script src="https://app.unpkg.com/framer-motion@12.12.1/dist/framer-motion.min.js"></script>
  </head>
  <Theme>
    <Header />
    <main class="events-list-page pt-xl pb-3xl">
      <div class="events-layout">
        <!-- Left panel: Tags -->
        <aside class="tags-panel">
          <h2 class="tags-header">Popular Topics</h2>
            <ul class="tags-list" style="align-items: flex-start;">            
            {mergedTags.map(tag => (
              <li class="tag-item" tabindex="0" data-tag={tag} style="text-align: left;">#{tag}</li>
            ))}
            </ul>        
        </aside>
        <!-- Main content: Events -->
      <div class="container">
      <h1 class="text-3xl text-bold text-accent mb-xl">
        Upcoming Events
      </h1>      
      <div class="container">
        <section>
              <div class="event-search form-control">
                <i class="form-control__prepend fa fa-search"></i>
                <input
                  id="event-search__input"
                  type="text"
                  class="form-control__input"
                  placeholder="Search events by name, tags, organizer..."
                />
                <button id="event-search__clear" class="form-control__append" style="display: none;">
                  <i class="fa fa-times"></i>
                </button>
                <div id="search-loader" class="search-loader" style="display: none;">
                  <div class="search-loader__spinner"></div>
                </div>
              </div>
              <div class="search-results-info mb-m">
                <p>Showing <span id="results-count" class="results-count">0</span> results</p>
              </div>
          { Object.keys(groupedEvents).length > 0 ? (
            Object.keys(groupedEvents).map((date) => (
              <div class="event-date">
                <fieldset class="mb-s mt-m" style="border-bottom: 0px; border-left: 0px; border-right: 0px; border-color: var(--gray-7);">
                  <legend class="text-3xl text-bold text-gray-7 px-m">
                    {date}
                  </legend>
                </fieldset>

                <ul class="event-list">
                  {
                    groupedEvents[date].map((event) => (
                      <li class="event-list-item" data-id={event.id}>
                        <EventCard event={event} />
                      </li>
                    ))
                  }
                </ul>
              </div>
            ))
          ) : (
            <p class="text-gray-5 text-2xl">No upcoming events found.</p>
          )}

          <div class="event-list__empty hide">
            <p class="text-gray-5 text-2xl">No results found ðŸ¤•</p>
          </div>
        </section>
      </div>
      </div>
    </main>
    <Footer />
  </Theme>
  <script>
    // Import search utilities
    import { normalize, debounce, filterEvents, animateElement, animateNumber } from '../../utils/searchUtils.js';
    // Fetch search index
    const events = [];
    fetch('/events/search-index.json')
      .then(response => response.json())
      .then(data => {
        events.push(...data);
        // Show total count on initial load
        updateResultsCount(events.length);
        // Add animation class after initial load
        document.querySelectorAll('.event-list-item').forEach(item => {
          item.classList.add('loaded');
        });
      })
      .catch(error => console.error('Error fetching search index:', error));

    // DOM elements
    const searchInput = document.querySelector('#event-search__input');
    const clearButton = document.querySelector('#event-search__clear');
    const emptyState = document.querySelector('.event-list__empty');
    const resultsInfo = document.querySelector('.search-results-info');
    const resultsCount = document.querySelector('#results-count');
    const eventItems = document.querySelectorAll('.event-list-item');
    const searchLoader = document.querySelector('#search-loader');

    // Initialize results count with the total number from DOM
    updateResultsCount(eventItems.length);

    // Helper function to update results count display
    function updateResultsCount(count) {
      // Animate count change
      const currentCount = parseInt(resultsCount.textContent);
      animateNumber(resultsCount, currentCount, count, 300);
      resultsInfo.style.display = 'block';
    }

    let selectedTags = [];

    document.querySelectorAll('.tag-item').forEach(el => {
      el.addEventListener('click', () => {
        const tag = el.getAttribute('data-tag');
        // Toggle selection
        if (selectedTags.includes(tag)) {
          selectedTags = selectedTags.filter(t => t !== tag);
          el.classList.remove('selected');
          //console.log(`Tag ${tag} deselected`);
        } else {
          selectedTags.push(tag);
          el.classList.add('selected');
          //console.log(`Tag ${tag} selected`);
        }
        filterByTags();
      });
    });

    function filterByTags() {
      // If no tags selected, show all events
      if (selectedTags.length === 0) {
        eventItems.forEach(item => animateElement(item, true));
        updateResultsCount(eventItems.length);
        animateElement(emptyState, false);
        return;
      }

      // Filter events by any selected tag
      const matches = events.filter(event =>
        (event.tags ?? []).some(tag => selectedTags.includes(tag.toLowerCase()))
      );
      //console.log(`Filtered by tags: ${selectedTags.join(', ')}`);

      updateResultsCount(matches.length);
      animateElement(emptyState, matches.length === 0);

      eventItems.forEach((item, index) => {
        const eventId = item.getAttribute('data-id');
        const visible = matches.some(event => event.id === eventId);

        setTimeout(() => {
          animateElement(item, visible);
        }, index % 5 * 50);
      });
    }

    // Optional: clear tag filter when search input is used
    searchInput.addEventListener('input', () => {
      selectedTags = [];
      document.querySelectorAll('.tag-item').forEach(el => el.classList.remove('selected'));
    });    
    
    // Search implementation
    const performSearch = () => {
      const query = searchInput.value.toLowerCase().trim();
      
      // Toggle clear button visibility
      clearButton.style.display = query ? 'block' : 'none';
      
      // If empty query, show all events
      if (!query) {
        animateElement(emptyState, false);
        eventItems.forEach(item => {
          animateElement(item, true);
        });
        updateResultsCount(eventItems.length);
        return;
      }

      // Filter events using the utility function
      const matches = filterEvents(events, query);

      // Update UI based on results
      updateResultsCount(matches.length);
      animateElement(emptyState, matches.length === 0);
      
      // Show/hide matching events with staggered animation
      eventItems.forEach((item, index) => {
        const eventId = item.getAttribute('data-id');
        const visible = matches.some(event => event.id === eventId);
        
        // Add slight delay based on index for staggered effect
        setTimeout(() => {
          animateElement(item, visible);
        }, index % 5 * 50); // Stagger in groups of 5
      });
    };

    // Set up event listeners with loading indicator
    const debouncedSearch = debounce(() => {
      searchLoader.style.display = 'none';
      performSearch();
    }, 400);
    
    searchInput.addEventListener('input', () => {
      searchLoader.style.display = 'block';
      debouncedSearch();
    });
    
    clearButton.addEventListener('click', () => {
      searchInput.value = '';
      performSearch();
      searchInput.focus();
    });
  </script>
</html>

<style lang="scss">
  .events-list-page {
    text-align: center;
  }

  ul.event-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .form-control__append {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: #999;
    cursor: pointer;
    padding: 5px;
    
    &:hover {
      color: #666;
    }
  }
  
  .event-list-item {
    transition: transform 0.3s ease-out, opacity 0.4s ease-out, height 0.5s ease-out;
    opacity: 0;
    transform: translateY(20px);
    height: auto;
    overflow: hidden;
    
    &.loaded {
      opacity: 1;
      transform: translateY(0);
    }
    
    &.hide {
      opacity: 0;
      height: 0;
      margin: 0;
      padding: 0;
      transform: translateY(10px);
    }
  }
  
  .hide {
    display: none;
  }
  
  .search-results-info {
    text-align: center;
    color: #666;
    font-size: 0.9rem;
    margin-top: 1rem;
    transition: opacity 0.3s ease;
    
    .results-count {
      font-weight: bold;
      color: #555;
    }
  }
  
  .event-list__empty {
    text-align: center;
    margin: 3rem 0;
    transition: opacity 0.3s ease, transform 0.4s ease;
    opacity: 0;
    transform: scale(0.95);
    
    &:not(.hide) {
      opacity: 1;
      transform: scale(1);
    }
  }
  
  .search-loader {
    position: absolute;
    right: 40px;
    top: 50%;
    transform: translateY(-50%);
    
    &__spinner {
      width: 18px;
      height: 18px;
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-top-color: #767676;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

    .events-layout {
    display: flex;
    align-items: flex-start;
    width: 100%;
  }
  .tags-panel {
    min-width: 180px;
    max-width: 220px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.03);
    padding: 1.5rem 1rem;
    margin-right: 2rem;
    max-height: 600px;
    overflow-y: auto;
    position: sticky;
    top: 2rem;
    transition: transform 0.3s, opacity 0.3s;
  }

  // Hide tags panel on mobile, show toggle button
  @media (max-width: 800px) {
    .tags-panel {
      position: fixed;
      left: 0;
      top: 0;
      height: 100vh;
      max-height: none;
      width: 80vw;
      min-width: 0;
      max-width: 320px;
      margin-right: 0;
      transform: translateX(-100%);
      opacity: 0;
      pointer-events: none;
      box-shadow: 2px 0 16px rgba(0,0,0,0.08);
      transition: transform 0.3s, opacity 0.3s;
    }
    .tags-panel.open {
      transform: translateX(0);
      opacity: 1;
      pointer-events: auto;
    }
    .tags-toggle-btn {
      display: block;
    }
    .events-layout {
      flex-direction: column;
    }
  }

  // Hide toggle button on desktop
  .tags-toggle-btn {
    display: none;
    position: fixed;
    left: 1rem;
    top: 1rem;
    z-index: 30;
    background: #3182ce;
    color: #fff;
    border: none;
    border-radius: 6px;
    padding: 0.6rem 1.2rem;
    font-size: 1rem;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    transition: background 0.2s;
  }
  .tags-toggle-btn:active, .tags-toggle-btn:focus {
    background: #225ea8;
  }
  .tags-header {
    font-size: 1.2rem;
    font-weight: bold;
    margin-bottom: 1rem;
    color: #444;
    text-align: left;
  }
  .tags-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  .tag-item {
    border-radius: 5px;
    padding: 0.4rem 0.8rem;
    color: #2d3748;
    font-size: 1rem;
    cursor: pointer;
    transition: background 0.2s;
    outline: none;
    border: none;
    &:hover, &:focus {
      background: #e2e8f0;
      color: #1a202c;
    }
  }
    .tag-item.selected {
    background: #3182ce;
    color: #fff;
  }
  .container {
    flex: 1 1 0%;
    max-width: 1200px;
    margin: 0 auto;
  }

</style>
